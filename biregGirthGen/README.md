# biregGirthGen

This directory contains code that generates all $(\lbrace r,m\rbrace ;g)$-graphs of order $n$, given $r$, $m$, $g$ and $n$, for $n$ up to 128.


In order to understand the different options of execution, we will explain some more algorithmic details. The graphs are generated by recursively adding edges to a starting graph. The differented obtained graphs during the execution are structured in a search tree.

The generation can either be done in one or two phases.

 - One phase: one process generates all the $(\lbrace r,m\rbrace ;g)$-graphs.
 - Two phases: one process computes the search tree up to a certain level $\ell_0$ and writes all obtained intermediary graphs to files. In the second phase the search of the intermediary graphs gets completed independently by $N$ different processes.

The approach in two phases originates from [1].


## Data

### Exhaustive lists

This directory contains exhaustive lists of $(\lbrace r,m\rbrace ;g)$-cages (which are $(\lbrace r,m\rbrace ;g)$-graphs of minimum order). A file `n<n>_r<r>_m<m>_g<g>.g6` contains all the  $(\lbrace r,m\rbrace ;g)$-cages of order $n$., e.g. `n19_r3_m6_g5.g6`.


## Code

### Compilation

In order to execute this code, one should first compile. There are several options to compile.

 - `make biregGirth`: Creates the `biregGirthGen` executable supporting up to and including 64 vertices.
 - `make biregGirth-128`: Creates the `biregGirthGen-128` executable supporting up to and including 128 vertices.
 - `make biregGirth-128-array`: Creates the `biregGirthGen-128-array` executable supporting up to and including 128 vertices. This version uses another internal representation of the $\texttt{bitset}$ as opposed to `biregGirthGen-128` and tends to be more efficient.

Each of the above three options also has a version for profiling with gprof. In order to compile these, add the suffix `-profiler`, e.g. `biregGirth-profiler`.

One can delete all executables with the `clean` command.


### Execution

To run the generator, the following command

```
./biregGirthGen <n> <r> <m> <g> <l0> <l1> <l2> <phase> <res> <mod>
````
where
 - `<n>`, `<r>`, `<m>` and `<g>`: have the same meaning as specified above.
 - `<l0>`: the level $\ell_0$ in the search tree up until you want the process of the first phase to go. In case you want to run the generation in one phase, you can set this variable to a value larger then the amount of edges that the $(\lbrace r,m\rbrace ;g)$-graph could have. The number 99999999 should be fine.
 - `<l1>` and `<l2>`: the other two level parameters $\ell_1, \ell_2$ from [1]. These limit the depth in the search up to which you perform a certain expensive pruning rule. It should be the case that $\ell_0 > \ell_1 > \ell_2$. For more information, consult [1]. 
 - `<phase>`: either equal to `1` if this is the first phase or equal to `2` if this is the second phase.
 - `<res>` and `<mod>`: `<mod>` needs to be equal to the amount of processes $N$ you use for the second phase. In case `<phase>` is equal to `1`, `<res>` can be any non-negative integer. In case `<phase>` is equal to `1`, then `<res>` is equal to the process number $i \in \lbrace 0,1, \ldots, N-1\rbrace $. Note that the values of `<res>` and `<mod>` do not matter if you only use one phase; you can use e.g. `<res>`  = `1` and `<mod>` = `1`.

Information on the program execution is sent to stderr and the generated $(\lbrace r,m\rbrace ;g)$-graphs are sent to stdout in graph6 format.

#### Example in one phase

Suppose you want to generate all the $(\lbrace 3,4\rbrace ;7)$-graphs of order $n=29$ in one phase. Then you can use the following command.
```
./biregGirthGen 29 3 4 7 99999999 7 3 1 1 1
```
This gives the following output in stderr
```
Options:
n r m g l0 l1 l2: 29 3 4 7 99999999 7 3
First Phase
Number of graphs visited with 29 vertices: 711
Number of ({3,4};7)-graphs found with 29 vertices: 11
Time spent: 0.052419 s
Search ended successfully
```
and the following output in stdout (the graphs in graph6 format).
```
\????????@_C?P?_?O?A?AC?C?OGA?O@AK??_o?@?GAGC?_O?Q?GCC?A@C??_CC?{????
\???????G??@?a?P?G?C?@C?G_?O?_G@AK??_o??_OAC?_OO?`?O?Q?AAA?@@@??{????
\????????@?A?O?_?H?CG@G?GO?GA?OCAK??_o??`?AAA?OO?E?O?H?C@G?@?K??{????
\?????????_C?O?_?G_COAG?CO?GA?OCAK??_o??__AC@_?CGO?O?E?G?C_@?CC?{????
\????????@?A?O?_?H?CG@C?G_?GA?OCAK??_o??_GACA?_CGO?OAC?G?P?@?@C?{????
\????????????`?W?I?CO@@?CG?P??O_AK??_o??_GACB??GG_?O?C_G?D??_AG?{????
\???????G????_?c?G_AO@@?CG?P??OCAK??_o?A?OAGA@?G?P?G?G_ACA??_K??{????
\????????@???_?S?G_CO@@?CO?P??OCAK??_o??_GAGC@?OC_?G?G_C?A_?_Q??{????
\??????????C?O?c?G_CO@C?CG?P??OCAK??_o?A?GGAC@?O?OOGCG?C?AO?_S??{????
\????????????W?`?H?C_@G?GC?GO?O_AK??_o??`G?AB??O?H?O?E?C?OG@?AC?{????
\????????????S?a?S?AGAG?CC?G_?OOAK??_o??_GAC@?OO?P?O?a?AAC?@@?_?{????
```



#### Example in two phases

Suppose you want to generate all the $(\lbrace 4,6\rbrace ;5)$-graphs of order $n=25$ in two phases and want to make use of $N=5$ processes in the second phase.  Then you can use the following command for the first phase.
```
./biregGirthGen 25 4 6 5 16 12 6 1 1 5
```
This gives the following output (only stderr).
```
Options:
n r m g l0 l1 l2: 25 4 6 5 16 12 6
First Phase
Wrote 17540 sub-searches to 5 files
Number of graphs visited with 25 vertices: 33720
Number of ({4,6};5)-graphs found with 25 vertices: 0
Time spent: 15.698640 s
Search ended successfully
```
Now the 17540 intermediary graphs are saved among $N=5$ files. We perform the second phase by calling
```
./biregGirthGen 25 4 6 5 16 12 6 2 <res> 5
``` 
for each `<res>` $\in \lbrace 0,1,2,3,4\rbrace $, which boils down to the following.
```
./biregGirthGen 25 4 6 5 16 12 6 2 0 5
./biregGirthGen 25 4 6 5 16 12 6 2 1 5
./biregGirthGen 25 4 6 5 16 12 6 2 2 5
./biregGirthGen 25 4 6 5 16 12 6 2 3 5
./biregGirthGen 25 4 6 5 16 12 6 2 4 5
```
The stderr output of the first command is
```
Options:
n r m g l0 l1 l2: 25 4 6 5 16 12 6
Second Phase: subbranches res 0
Sub-search 500 done
Sub-search 1000 done
Sub-search 1500 done
Sub-search 2000 done
Sub-search 2500 done
Sub-search 3000 done
Sub-search 3500 done
End of file reached
3508 searches done
Number of graphs visited with 25 vertices: 4485608
Number of ({4,6};5)-graphs found with 25 vertices: 77135
Time spent: 46.761079 s
Search ended successfully
```
The stdout output of all five commands should contain all $(\lbrace 4,6\rbrace ;5)$-graphs of order $25$, but not isomorphism-free. In order to only have the pairwise non-isomorphic graphs, one can use the `shortg` command from nauty (which is also available in this repository).


## References

[1]  G. Exoo, B. D. McKay, W. Myrvold, and J. Nadon. Computational determination of (3,11) and (4,7) cages. Journal of Discrete Algorithms, 9(2):166â€“169, 2011.
